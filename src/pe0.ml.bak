open Common
open Core
open State_monad


    
let bool_t = NomT "bool"

let rec type_of_const : const -> t = function
    | NoneL -> NoneT
    | UndefL -> BottomT
    | IntL _ -> NomT "int"
    | BoolL _ -> NomT "bool"
    | FloatL _ -> NomT "float"
    | StrL _  -> NomT "string"
    | TupleL xs -> TupleT (List.map type_of_const xs)
    | InstrinsicL c -> IntrinsicT c
    | TypeL t       -> TypeT t

exception NonStaticTypeCheck
let rec type_less : t -> t -> bool = fun a b ->
    match a, b with
    | TopT, _ -> raise NonStaticTypeCheck
    | _, TopT -> true
    | BottomT, _ -> true
    | UnionT xs, UnionT ys ->

        let xs = List.concat @@ List.map (fun x -> List.map (type_less x) ys) xs in
        if List.for_all (fun x -> x) xs then
            true
        else if List.for_all (fun x -> not x) xs  then
            false
        else
            raise NonStaticTypeCheck
    | x, UnionT xs ->
        List.exists (type_less x) xs
    | _ -> false

let rec sequence : 'a list list -> 'a list list =
    function
    | [g] -> flip List.map g (fun x -> [x])
    | g1::gs ->
        let tls = sequence gs in
        List.concat @@
        flip List.map tls @@ fun tl ->
            flip List.map g1 @@ flip List.cons tl
    | [] -> []

let gensym : int -> int ref -> var = fun scope_level count ->
    let v = !count in
    incr count; (scope_level, string_of_int v)

let union_types : (pe_state, (int * t) list list) MState.state =
    let open MState in
    get >>= fun {slots; n2i; var_count; lbl_count; _} ->    
        let unions = 
            List.unwrap_seq @@
            Array.to_list @@
            Array.mapi
            (fun i ->
                function
                | {typ = UnionT ts; _} -> Some (i, ts)
                | _ -> None)
            slots
        in
        let indices, tss = List.unzip unions in
        let tss = sequence tss in
        return @@ List.map (List.zip indices) tss
        
        (* let lbls = Array.init (List.length tss + 1) (fun _ -> gensym 0 var_count) in
        
        let n_union = List.length indices in
        let instrs = Darray.empty() in
        let all_states = List.mapi (fun branch_i ts ->
            let slots =  Array.copy slots in
            let conds = Array.make n_union (Obj.magic 0) in
            List.iter2
                (fun idx t ->
                    let sym = gensym 0 var_count in
                    begin
                        conds.(idx) <- D sym;
                        Darray.append instrs @@
                            Call(
                                Some sym,
                                S (InstrinsicL IsTypeOf),
                                [slots.(idx).value; S (TypeL t)],
                                []
                            );
                        slots.(idx) <- {slots.(idx) with typ = t};
                    end
                ) indices ts;
            let cond_var = gensym 0 var_count in
            let _ = Darray.append
                        instrs
                        @@ Call(Some cond_var, S (InstrinsicL BoolOr), Array.to_list conds, []) in
            let _ = Darray.append
                        instrs
                        @@ GotoIf(D cond_var, lbls.(branch_i), lbls.(branch_i + 1)) in
            slots
        ) tss
        in failwith "" *)

let create_bb_from_config
    = fun conf k ->
    let open MState in
    get >>= fun {out_bbs; lbl_count; scope_level; _} ->
    match M_state.find_opt conf !out_bbs with
    | Some (lbl, _) -> return lbl
    | None ->
        let lbl = gensym scope_level lbl_count in
        k lbl out_bbs


let extend_m : 'a Darray.darray -> ('s, 'a list) MState.state -> ('s, unit) MState.state =
    let open MState in
    fun arr m -> m >>= fun xs -> return (List.iter (Darray.append arr) xs)
        
let rec specialise_bb : basic_blocks -> label -> (pe_state, label) MState.state =
    fun blocks cur_lbl ->
    let open MState in
    get >>= fun ({slots; n2i; out_bbs; lbl_count; _} as st) ->
    let {suite; phi} = Smap.find cur_lbl blocks in
    let slots' = Array.copy slots in
    let instrs = Darray.empty() in
    let prepare_phi : (var, var) Smap.smap -> unit =
        let iter_do (reg, from) =
            let _ = Darray.append instrs (Assign (reg, D from)) in
            let i_reg, i_from = Smap.find reg n2i, Smap.find from n2i in
            let v1 = slots'.(i_reg) in
            let v2 = slots.(i_from) in
            if v2.typ = BottomT
            then failwith "NameError detected"
            else
            if v1.typ = BottomT
            then slots'.(i_reg) <- v2
            else
            slots'.(i_reg) <- {
                typ=v2.typ;
                value=v2.value
            }
        in List.iter iter_do
    in
    let _ = prepare_phi @@ Smap.find cur_lbl phi in
    let config = (cur_lbl, slots') in
    create_bb_from_config config @@ fun gen_lbl out_bbs ->
        let _ = out_bbs := M_state.add config (gen_lbl, instrs) !out_bbs in
        put {st with slots = slots; out_bbs = out_bbs; reached = Sset.add cur_lbl st.reached}
        >> union_types
        >>= function
        | [] -> (* no union split, avoid generating redundant labels *) 
            extend_m instrs (specialise_instrs blocks suite) >> return gen_lbl
        | branches -> get
        >>= fun ({slots; reached; scope_level; _} as pe_state) ->
        let cases =
            flip List.map branches @@ fun branch ->
            let slots' = Array.copy slots in
            let checks =
                flip List.map branch @@ fun (slot_idx, t) ->
                    let slot = slots.(slot_idx) in
                    slots'.(slot_idx) <- {slot with typ = t};
                    (slot.value, t)
            in
            let gen_branch_lbl = gensym scope_level lbl_count in
            let new_instrs = Darray.empty() in
            let _ = out_bbs := M_state.add config (gen_branch_lbl, new_instrs) !out_bbs in
            let m = extend_m new_instrs (specialise_instrs blocks suite) in
            ignore (m.run_state {pe_state with slots=slots'});
            (checks, gen_branch_lbl)
        in Darray.append instrs (TypeSwitch cases); return gen_lbl
    
and specialise_instrs : basic_blocks -> instr list -> (pe_state, instr list) MState.state =
    let open MState in
    fun blocks ->
    function
    | [] -> return []
    | instr::xs ->
    let get_tailm() = specialise_instrs blocks xs in
    match instr with
    | Goto lbl | GotoIf (Const (BoolL true), lbl, _) ->
        specialise_bb blocks lbl >>= fun lbl ->
        return @@ [Goto lbl]

    | GotoIf (Const (BoolL false), _, lbl) ->
        specialise_bb blocks lbl >>= fun lbl ->
        return @@ [Goto lbl]

    | GotoIf (Const _, _, _) ->
        failwith "internal error"

    | GotoIf (Var var, l1, l2) ->
        get >>= fun ({slots; n2i;_}) ->
        let i = Smap.find var n2i in
        let v1 = slots.(i) in begin
        match v1.value with
        | S (BoolL true) ->
            specialise_bb blocks l1 >>= fun lbl ->
            return @@ [Goto lbl]
        | S (BoolL false) ->
            specialise_bb blocks l2 >>= fun lbl ->
            return @@ [Goto lbl]
        | _ ->
            specialise_bb blocks l1 >>= fun l1 ->
            specialise_bb blocks l2 >>= fun l2 ->
            get_tailm() >>= fun tl -> return @@ GotoIf(Var var, l1, l2)::tl
        end
    | Return _ ->
        return [instr]
    
    | Assign(var, Const const) ->
        get >>= fun ({slots; n2i;_} as pe_state) ->
        let ty = type_of_const const in
        let i1 = Smap.find var n2i in
        let v1 = slots.(i1) in
        let v2 = {typ = ty; value=S const} in
        if v1 = v2 then
            get_tailm()
        else
            let slots' = Array.copy slots in
            (if v1.typ = BottomT then
                slots'.(i1) <- v2
            else
                (* so far no register allocation optim,
                   hence reusing variables cause inefficiency.
                *)
                slots'.(i1) <- {typ = type_union v1.typ v2.typ; value=v2.value}
            );
            put {pe_state with slots = slots'} >>
            (* we can later optimize unused variables *)
            get_tailm() >>= fun tl -> return @@ instr::tl
    
    | Assign(var, Var from) ->
        get >>= fun ({slots; n2i;_} as pe_state) ->
        let i1, i2 = Smap.find var n2i, Smap.find from n2i in
        let v1, v2 = slots.(i1), slots.(i2) in
        if v1 = v2 then
            get_tailm ()
        else
            let slots' = Array.copy slots in
            let _ = slots'.(i1) <- v2 in
            put {pe_state with slots = slots'} >>
            (get_tailm() >>= fun tl -> return @@ instr::tl)
        
    | Call(Some bound, Const (InstrinsicL IsTypeOf), [r1, r2], []) ->
        get >>= fun ({slots; n2i;_} as pe_state) ->
        let bi, vi = Smap.find bound n2i, Smap.find var n2i in
        let vv = slots.(vi) in begin
        match vv.typ with
        | TypeT ty -> begin
            try
                let test = S (BoolL (type_less ty vv.typ)) in
                let slots' = Array.copy slots in
                let _ = slots'.(bi) <- {typ = type_union slots.(bi).typ bool_t; value=test} in
                put {pe_state with slots=slots'} >> get_tailm ()
            with NonStaticTypeCheck ->
                get_tailm() >>= fun tl -> return @@ instr :: tl
            end
        | _ ->
            get_tailm() >>= fun tl -> return @@ instr :: tl
        end
        
    | Call(_, _, _, _) ->
        failwith "TODO"


and specialise :  func_def (* current function *)
    -> func_def M_int.t (* all function pointers *)
    -> (label * instr list) list (* specialized body *)
    = fun { func_entry={args; kwargs; closure; other_bounds}; body } f_defs ->
    let mk = List.map (fun (var, t) ->  {typ = t; value=D var}) in
    let ns = args @ kwargs @ closure @ other_bounds in
    let n2i = List.mapi (fun i (x, _) -> (x, i)) ns in
    let states = Array.of_list @@ mk ns in
    let init_state = {slots = states ; n2i = n2i; reached = M_state.empty; i2f = f_defs; lbl_count = ref 0; var_count = ref 0} in
    let m = specialise_bb body (0, "entry") in
    let (_, {reached; _}) = m.run_state init_state in 
    List.map
        (fun (_, (lbl, bb)) -> lbl, Darray.to_list bb)
        @@ M_state.bindings reached
