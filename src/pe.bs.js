// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Eff$Jit = require("./eff.bs.js");
var Smap$Jit = require("./smap.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Common$Jit = require("./common.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var NonStaticTypeCheck = Caml_exceptions.create("Pe-Jit.NonStaticTypeCheck");

function type_less(a, b) {
  if (typeof a === "number") {
    switch (a) {
      case /* TopT */1 :
          throw NonStaticTypeCheck;
      case /* BottomT */2 :
          return true;
      default:
        
    }
  } else if (a.tag === /* UnionT */6) {
    if (typeof b === "number") {
      if (b !== /* TopT */1) {
        return false;
      }
      
    } else {
      if (b.tag !== /* UnionT */6) {
        return false;
      }
      var ys = b[0];
      var xs = Curry._1(Common$Jit.List.concat, Curry._2(Common$Jit.List.map, (function (x) {
                  return Curry._2(Common$Jit.List.map, (function (param) {
                                return type_less(x, param);
                              }), ys);
                }), a[0]));
      if (Curry._2(Common$Jit.List.for_all, (function (x) {
                return x;
              }), xs)) {
        return true;
      }
      if (Curry._2(Common$Jit.List.for_all, (function (x) {
                return !x;
              }), xs)) {
        return false;
      }
      throw NonStaticTypeCheck;
    }
  }
  if (typeof b === "number") {
    if (b === /* TopT */1) {
      return true;
    } else {
      return false;
    }
  } else if (b.tag === /* UnionT */6) {
    return Curry._2(Common$Jit.List.exists, (function (param) {
                  return type_less(a, param);
                }), b[0]);
  } else {
    return false;
  }
}

function specialise_bb(S, param) {
  var jump_to = param[1];
  var bbs = param[0];
  var match = Smap$Jit.find(jump_to, bbs);
  var suite = match.suite;
  Curry._1(S.assign_vars, Smap$Jit.find(S.it.cur_lbl, match.phi));
  var config_001 = Curry._1(Common$Jit.$$Array.copy, S.it.slots);
  var config = /* tuple */[
    jump_to,
    config_001
  ];
  var match$1 = Curry._1(S.lookup_config, config);
  if (match$1 !== undefined) {
    return match$1[0];
  }
  var link = Curry._1(S.add_config, config);
  var link_lbl = link[0];
  Curry._1(S.enter_block, link);
  var is_def_generated;
  if (Curry._1(S.has_reached, jump_to)) {
    Curry._1(S.dynamicalize_all, undefined);
    var match$2 = Curry._1(S.lookup_config, Curry._1(S.make_config, undefined));
    if (match$2 !== undefined) {
      Curry._1(S.add_instr, /* Ir_goto */Block.__(3, [match$2[0]]));
      is_def_generated = true;
    } else {
      var def = Curry._1(S.add_config, Curry._1(S.make_config, undefined));
      Curry._1(S.add_instr, /* Ir_goto */Block.__(3, [def[0]]));
      Curry._1(S.enter_block, def);
      is_def_generated = false;
    }
  } else {
    is_def_generated = false;
  }
  if (is_def_generated) {
    return link_lbl;
  }
  var union_types = Curry._1(S.union_types, undefined);
  if (union_types) {
    var go = function (param) {
      if (!param) {
        return /* Ir_block */Block.__(7, [specialise_instrs(S, /* tuple */[
                        bbs,
                        suite
                      ])]);
      }
      var tl = param[1];
      var match = param[0];
      var v = Caml_array.caml_array_get(S.it.slots, match[0]).value;
      if (!v.tag) {
        return Pervasives.failwith("TODO");
      }
      var $$var = v[0];
      var cases = Common$Jit.flip(Common$Jit.List.map, match[1], (function (t) {
              return /* tuple */[
                      /* TypeL */Block.__(6, [t]),
                      Curry._1(S.with_local, (function (param) {
                              Curry._1(S.set_type, /* tuple */[
                                    $$var,
                                    t
                                  ]);
                              return go(tl);
                            }))
                    ];
            }));
      var func = Curry._1(S.repr_eval, /* S */Block.__(0, [/* InstrinsicL */Block.__(5, [/* TypeOf */4])]));
      var arg = Curry._1(S.repr_eval, v);
      var expr_000 = /* Ir_s */Block.__(0, [func]);
      var expr_001 = /* :: */[
        /* Ir_s */Block.__(0, [arg]),
        /* [] */0
      ];
      var expr = /* Ir_call */Block.__(1, [
          expr_000,
          expr_001,
          /* [] */0
        ]);
      return /* Ir_switch */Block.__(0, [
                expr,
                cases
              ]);
    };
    Curry._1(S.add_instr, go(union_types));
    return link_lbl;
  }
  Curry._2(Common$Jit.List.iter, S.add_instr, Curry._1(S.with_local, (function (param) {
              return specialise_instrs(S, /* tuple */[
                          bbs,
                          suite
                        ]);
            })));
  return link_lbl;
}

function specialise_instrs(S, param) {
  var bbs = param[0];
  var go = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var l = param[0];
      switch (l.tag | 0) {
        case /* GotoIf */0 :
            var f = l[2];
            var t = l[1];
            var cond = Curry._1(S.repr_eval, l[0]);
            var match = cond.value;
            if (match.tag) {
              if (cond.typ !== Eff$Jit.bool_t) {
                return Pervasives.failwith("TODO");
              }
              var t$1 = specialise_bb(S, /* tuple */[
                    bbs,
                    t
                  ]);
              var f$1 = specialise_bb(S, /* tuple */[
                    bbs,
                    f
                  ]);
              return /* :: */[
                      /* Ir_gotoif */Block.__(2, [
                          /* Ir_s */Block.__(0, [cond]),
                          t$1,
                          f$1
                        ]),
                      /* [] */0
                    ];
            }
            var match$1 = match[0];
            if (typeof match$1 === "number") {
              return Pervasives.failwith("TODO");
            }
            if (match$1.tag !== /* BoolL */1) {
              return Pervasives.failwith("TODO");
            }
            if (match$1[0]) {
              var t$2 = specialise_bb(S, /* tuple */[
                    bbs,
                    t
                  ]);
              return /* :: */[
                      /* Ir_goto */Block.__(3, [t$2]),
                      /* [] */0
                    ];
            }
            var f$2 = specialise_bb(S, /* tuple */[
                  bbs,
                  f
                ]);
            return /* :: */[
                    /* Ir_goto */Block.__(3, [f$2]),
                    /* [] */0
                  ];
        case /* Goto */1 :
            var l$1 = specialise_bb(S, /* tuple */[
                  bbs,
                  l[0]
                ]);
            return /* :: */[
                    /* Ir_goto */Block.__(3, [l$1]),
                    /* [] */0
                  ];
        case /* Assign */2 :
            var tl = param[1];
            var target = l[0];
            var i = Smap$Jit.find(target, S.it.n2i);
            var from = Curry._1(S.repr_eval, l[1]);
            Caml_array.caml_array_set(S.it.slots, i, from);
            if (from.value.tag) {
              return /* :: */[
                      /* Ir_assign */Block.__(4, [
                          target,
                          /* Ir_s */Block.__(0, [from])
                        ]),
                      go(tl)
                    ];
            }
            _param = tl;
            continue ;
        case /* Return */3 :
            var value = Curry._1(S.repr_eval, l[0]);
            S.it.ret = Eff$Jit.type_union(value.typ, S.it.ret);
            return /* :: */[
                    /* Ir_return */Block.__(5, [/* Ir_s */Block.__(0, [value])]),
                    /* [] */0
                  ];
        case /* Call */4 :
            var bound = l[0];
            if (bound === undefined) {
              return Pervasives.failwith("TODO");
            }
            var func = Curry._1(S.repr_eval, l[1]);
            var args = Curry._2(Common$Jit.List.map, S.repr_eval, l[2]);
            var kwargs = Smap$Jit.map(S.repr_eval, l[3]);
            var match$2 = func.value;
            if (match$2.tag) {
              return Pervasives.failwith("TODO");
            }
            var match$3 = match$2[0];
            if (typeof match$3 === "number") {
              return Pervasives.failwith("TODO");
            }
            if (match$3.tag !== /* InstrinsicL */5) {
              return Pervasives.failwith("TODO");
            }
            if (match$3[0] !== 3) {
              return Pervasives.failwith("TODO");
            }
            if (!args) {
              return Pervasives.failwith("TODO");
            }
            var match$4 = args[1];
            if (!match$4) {
              return Pervasives.failwith("TODO");
            }
            var match$5 = match$4[0].value;
            if (match$5.tag) {
              return Pervasives.failwith("TODO");
            }
            var t2 = match$5[0];
            if (typeof t2 === "number") {
              return Pervasives.failwith("TODO");
            }
            if (t2.tag !== /* TypeL */6) {
              return Pervasives.failwith("TODO");
            }
            if (match$4[1]) {
              return Pervasives.failwith("TODO");
            }
            if (kwargs) {
              return Pervasives.failwith("TODO");
            }
            try {
              var test = type_less(args[0].typ, t2[0]);
              Curry._2(S.set_var, bound, (function(test){
                  return function (param) {
                    return {
                            typ: Eff$Jit.bool_t,
                            value: /* S */Block.__(0, [/* BoolL */Block.__(1, [test])])
                          };
                  }
                  }(test)));
              return go(param[1]);
            }
            catch (exn){
              if (exn === NonStaticTypeCheck) {
                return Pervasives.failwith("TODO");
              }
              throw exn;
            }
        
      }
    };
  };
  return go(param[1]);
}

exports.NonStaticTypeCheck = NonStaticTypeCheck;
exports.type_less = type_less;
exports.specialise_bb = specialise_bb;
exports.specialise_instrs = specialise_instrs;
/* Eff-Jit Not a pure module */
