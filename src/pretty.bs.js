// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Common$Jit = require("./common.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function show_repr(param) {
  if (param.tag) {
    return param[0][1];
  }
  var i = param[0];
  if (typeof i === "number") {
    return "<unsupported>";
  }
  switch (i.tag | 0) {
    case /* IntL */0 :
        return String(i[0]);
    case /* BoolL */1 :
        if (i[0]) {
          return "true";
        } else {
          return "false";
        }
    case /* FloatL */2 :
        return Pervasives.string_of_float(i[0]);
    case /* StrL */3 :
        return "str[" + (i[0] + "]");
    default:
      return "<unsupported>";
  }
}

function show_instr(r) {
  switch (r.tag | 0) {
    case /* GotoIf */0 :
        return "if " + (show_repr(r[0]) + (" goto " + (r[1][1] + (" goto " + r[2][1]))));
    case /* Goto */1 :
        var match = r[0];
        if (match[0] !== 0) {
          return "<unsupported>";
        } else {
          return "goto " + match[1];
        }
    case /* Assign */2 :
        return r[0][1] + (" = " + show_repr(r[1]));
    case /* Return */3 :
        return "return " + show_repr(r[0]);
    case /* Call */4 :
        var match$1 = r[0];
        if (match$1 !== undefined) {
          if (r[3]) {
            return "<unsupported>";
          } else {
            return match$1[1] + (" = call " + (show_repr(r[1]) + ("(" + ($$String.concat(",", Curry._2(Common$Jit.List.map, show_repr, r[2])) + ")"))));
          }
        } else if (r[3]) {
          return "<unsupported>";
        } else {
          return "call " + (show_repr(r[1]) + ("(" + ($$String.concat(",", Curry._2(Common$Jit.List.map, show_repr, r[2])) + ")")));
        }
    
  }
}

function show_phi(xs) {
  if (!xs) {
    return "";
  }
  var show_phi_each_source = function (param) {
    if (!param) {
      return /* [] */0;
    }
    var match = param[0];
    return /* :: */[
            "  " + (match[0][1] + (" <- " + match[1][1])),
            show_phi_each_source(param[1])
          ];
  };
  var content = $$String.concat("\n|", Common$Jit.flip(Common$Jit.List.map, xs, (function (param) {
              return param[0][1] + (":\n" + $$String.concat(",\n", show_phi_each_source(param[1])));
            })));
  return "\n " + (content + "\n");
}

function show_bb(param) {
  var match = param[1];
  return "LABEL " + (param[0][1] + (":\nPHI [" + (show_phi(match.phi) + ("]\n" + $$String.concat(";\n", Curry._2(Common$Jit.List.map, show_instr, match.suite))))));
}

function show_t(s) {
  if (typeof s === "number") {
    switch (s) {
      case /* TopT */1 :
          return "top";
      case /* BottomT */2 :
          return "bot";
      default:
        return Pervasives.failwith("TODO");
    }
  } else {
    switch (s.tag | 0) {
      case /* TypeT */2 :
          return "type[" + (show_t(s[0]) + "]");
      case /* NomT */4 :
          return "@" + s[0];
      case /* UnionT */6 :
          return "(" + ($$String.concat(" | ", Curry._2(Common$Jit.List.map, show_t, s[0])) + ")");
      case /* FPtrT */7 :
          return "fptr[" + (String(s[0]) + "]");
      default:
        return Pervasives.failwith("TODO");
    }
  }
}

function show_ann(param) {
  return param[0][1] + (": " + show_t(param[1]));
}

function show_func_def(param) {
  var match = param.func_entry;
  var body = $$String.concat("\n", Curry._2(Common$Jit.List.map, show_bb, param.body));
  var args = $$String.concat(", ", Curry._2(Common$Jit.List.map, show_ann, match.args));
  var globals = $$String.concat(", ", Curry._2(Common$Jit.List.map, show_ann, match.globals));
  var bounds = $$String.concat(", ", Curry._2(Common$Jit.List.map, show_ann, match.other_bounds));
  return "func (" + (args + (")\nbound [" + (bounds + ("]\nglobal [" + (globals + ("]\n" + body))))));
}

exports.show_repr = show_repr;
exports.show_instr = show_instr;
exports.show_phi = show_phi;
exports.show_bb = show_bb;
exports.show_t = show_t;
exports.show_ann = show_ann;
exports.show_func_def = show_func_def;
/* No side effect */
