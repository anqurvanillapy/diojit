\documentclass[12pt, a4paper]{report}

\usepackage[top=3.5cm,bottom=3cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[epsilon, tsrm, altpo]{backnaur}
\usepackage{listings}
\usepackage{mathtools}
\lstset{language=Caml, mathescape}
\bibliographystyle{unsrtnat}

\newcommand{\ddfrac}[3]{
    & #1 \\
    & \frac { #2 } { #3 }
}

\newcommand{\rulegroup}[1]{
    \textbf{#1}
}

\newcommand{\gap}{ \;\;\;\; }
\newcommand{\mbold}[1]{ \mathbf{#1} }

\title{Semantics for $\mathbf{DYNJIT}^\mathbf{source} \rightarrow \mathbf{DYNJIT}^\mathbf{target}$}


\begin{document}
\maketitle

\textbf{CoreCPY} can be always converted to $\mathbf{DYNJIT}^\mathbf{source}$
in a straightforward approach because,
\textbf{the stack usage of the bytecode generated by valid Python source code is finite}.

Regarding the perspective of partial evaluation,
we know \textbf{CoreCPY} is a flowchart language with a finite stack(a stack $S_N$ has a size$N$).

By assigning the abstract value $\mathbf{Dyn}\; s$ to a named variable $s$,
and assigning the abstract value $\mathbf{Slot}\; i$ to a datum stored in the $i$-th element from the bottom of stack(BOS) if initialized,
we will have finite configurations:

$$ \mathbf{Configurations} \subset \mathbf{Labels} \times 
\left[\mathbf{Dyn}\; s_1, \mathbf{Dyn}\; s_2, \cdots, \mathbf{Dyn}\; s_k \right]^k
\times \mathcal {P}(\{\mathbf{Slot}\; 1, \cdots, \mathbf {Slot}\; N \})
$$
where 
$\mathcal {P}$ means getting the power set, $k$ is the number of named variables not matter what it is(cell, free, etc.) and,
$N$, as we've mentioned above, is the size of the stack, which is finite for any given code.

Note that
$$ \left| \mathbf{Labels} \times 
\left[\mathbf{Dyn}\; s_1, \mathbf{Dyn}\; s_2, \cdots, \mathbf{Dyn}\; s_k \right]^k
\times \mathcal {P}(\{\mathbf{Slot}\; 1, \cdots, \mathbf {Slot}\; N \} \right| $$ is simply finite,
this leads to finite $\mathbf{Configurations}$, and also, finite basic blocks
when translating the use of stack to unnamed registers.

\newpage

\section*{
    $\mathbf{DYNJIT}^{\mathbf{source}}$ 
    and 
    $\mathbf{DYNJIT}^{\mathbf{target}}$
}

$\mathbf{DYNJIT}^{\mathbf{source}}$  \textbf{Syntax}
\begin{bnf*}
    \bnfprod{repr}{\bnftd{S} \bnfsp \bnftd{$\mathbf{constant}$}}\\
    \bnfmore{\bnfor \bnftd{D} \bnfsp \bnftd{$\mathbf{var}$}}\\
    \bnfprod{instr}{\bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnftd{call} \bnfsp \bnfpn{repr} \bnfsp \bnfts{(} \bnfpn{repr} \bnfsp \bnftd{*}\bnfts{)}}\\
    \bnfmore{\bnfor \bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnfpn{repr}}\\
    \bnfmore{\bnfor \bnftd{return} \bnfsp \bnfpn{repr}}\\
    \bnfmore{\bnfor \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$}}\\
    \bnfmore{\bnfor \bnftd{if} \bnfsp \bnfpn{repr} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$}}\\
    \bnfprod{move}{\bnfpn{var} \bnfsp \bnftd{$\leftarrow$} \bnfsp \bnfpn{var}}\\
    \bnfprod{$\Phi$}{\bnftd{$\mathbf{label}$} \bnfsp \bnftd{:} \bnfsp \bnfpn{move} \bnfsp \bnftd{*}}\\
    \bnfprod{basicblock}{\bnftd{label} \bnfsp \bnftd{$\mathbf{label}$} \bnfsp \bnftd{:} \bnfsp \bnftd{$\Phi$} \bnfsp \bnftd{[} \bnfsp \bnfpn{$\Phi$} \bnfsp \bnftd{*} \bnfsp \bnftd{]} \bnfsp \bnfpn{instr} \bnfsp \bnftd{+}}\\
    \bnfprod{entryblock}{\bnftd{label} \bnfsp \bnftd{entry} \bnfsp \bnftd{:} \bnfsp \bnftd{$\Phi$} \bnfsp \bnftd{[} \bnfsp \bnfpn{$\Phi$} \bnfsp \bnftd{*} \bnfsp \bnftd{]} \bnfsp \bnfpn{instr} \bnfsp \bnftd{+}}\\
    \bnfprod{basicblocks}{\bnfpn{entryblock} \bnfsp \bnfpn{basicblock} \bnfsp \bnftd{*}}\\
\end{bnf*}


$\mathbf{DYNJIT}^{\mathbf{target}}$  \textbf{Syntax}


\begin{bnf*}
    \bnfprod{absvalue}{\bnfts{(} \bnfpn{repr} \bnfsp \bnftd{,} \bnfsp \bnfpn{type} \bnfts{)}}\\
    \bnfprod{expr}{\bnfpn{absvalue}}\\
    \bnfmore{\bnfor \bnftd{call} \bnfsp \bnfpn{expr} \bnfsp \bnfts{(} \bnfpn{expr} \bnfsp \bnftd{*}\bnfts{)}}\\
    \bnfprod{stmt}{\bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{return} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{if} \bnfsp \bnfpn{expr} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{do} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{label} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{\{} \bnfsp \bnfpn{stmts} \bnfsp \bnftd{\}}}\\
    \bnfmore{\bnfor \bnftd{switch} \bnfsp \bnfpn{expr} \bnfsp \bnfpn{case} \bnfsp \bnftd{*}}\\
    \bnfprod{case}{\bnftd{$\mathit{|}$} \bnfsp \bnfpn{type} \bnfsp \bnftd{$\rightarrow$} \bnfsp \bnfpn{stmt}}\\
    \bnfprod{stmts}{\bnfpn{stmt} \bnfsp \bnftd{*}}\\
\end{bnf*}

\newpage

$\mathbf{Types}$

\begin{lstlisting}
type fptr = int
type meth = int
type t =
| TopT
| BottomT
| NoneT
| FPtrT  of fptr
| MethT  of meth
| NomT   of string * (string, t) map
| TupleT of t list
| TypeT  of t list
| CellT  of t list
| UnionT of t list
| IntrinT of intrinsic
\end{lstlisting}

\newpage

$\mathbf{Intrinsics}$ and $\mathbf{Constants}$

\begin{lstlisting}
type intrinsic =
| IsInstanceOf
| TypeOf
| BuildTuple
| Upcast
| Downcast

type const =
| NoneC
| UndefC
| TypeL  of t
| FPtrC  of fptr
| MethC  of meth
| IntC   of int
| FloatC of float
| StrC   of string
| TupleC of const list
| IntrinsicC of intrinsic
\end{lstlisting}


\end{document}