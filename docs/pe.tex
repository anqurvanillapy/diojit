\documentclass[12pt, a4paper]{report}

\usepackage[top=3.5cm,bottom=3cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[epsilon, tsrm, altpo]{backnaur}
\usepackage{listings}
\usepackage{mathtools}
\lstset{language=Caml, mathescape}
\bibliographystyle{unsrtnat}

\newcommand{\ddfrac}[3]{
    & #1 \\
    & \frac { #2 } { #3 }
}

\newcommand{\centerfrac}[4]{
    $$ #2 $$
    $$
        \dfrac { #3 } { #4 } #1
    $$
}

\newcommand{\negsp}[1]{
    \!\!#1\!\!
}


\newcommand{\rulegroup}[1]{
    \textbf{#1}
}

\newcommand{\gap}{ \;\;\;\; }
\newcommand{\mbold}[1]{ \mathbf{#1} }

\title{Semantics for $\mathbf{DYNJIT}^\mathbf{source} \rightarrow \mathbf{DYNJIT}^\mathbf{target}$}


\begin{document}
\maketitle

\textbf{CoreCPY} can be always converted to $\mathbf{DYNJIT}^\mathbf{source}$
in a straightforward approach because,
\textbf{the stack usage of the bytecode generated by valid Python source code is finite}.

Regarding the perspective of partial evaluation,
we know \textbf{CoreCPY} is a flowchart language with a finite stack(a stack $S_N$ has a size$N$).

By assigning the abstract value $\mathbf{Dyn}\; s$ to a named variable $s$,
and assigning the abstract value $\mathbf{Slot}\; i$ to a datum stored in the $i$-th element from the bottom of stack(BOS) if initialized,
we will have finite configurations:

$$ \mathbf{Configurations} \subset \mathbf{Labels} \times 
\left[\mathbf{Dyn}\; s_1, \mathbf{Dyn}\; s_2, \cdots, \mathbf{Dyn}\; s_k \right]^k
\times \mathcal {P}(\{\mathbf{Slot}\; 1, \cdots, \mathbf {Slot}\; N \})
$$
where 
$\mathcal {P}$ means getting the power set, $k$ is the number of named variables not matter what it is(cell, free, etc.) and,
$N$, as we've mentioned above, is the size of the stack, which is finite for any given code.

Note that
$$ \left| \mathbf{Labels} \times 
\left[\mathbf{Dyn}\; s_1, \mathbf{Dyn}\; s_2, \cdots, \mathbf{Dyn}\; s_k \right]^k
\times \mathcal {P}(\{\mathbf{Slot}\; 1, \cdots, \mathbf {Slot}\; N \} \right| $$ is simply finite,
this leads to finite $\mathbf{Configurations}$, and also, finite basic blocks
when translating the use of stack to unnamed registers.

\newpage

\section*{
    $\mathbf{DYNJIT}^{\mathbf{source}}$ 
    and 
    $\mathbf{DYNJIT}^{\mathbf{target}}$
}

$\mathbf{DYNJIT}^{\mathbf{source}}$  \textbf{Syntax}
\begin{bnf*}
    \bnfprod{repr}{\bnftd{S} \bnfsp \bnftd{$\mathbf{constant}$}}\\
    \bnfmore{\bnfor \bnftd{D} \bnfsp \bnftd{$\mathbf{var}$}}\\
    \bnfprod{instr}{\bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnftd{call} \bnfsp \bnfpn{repr} \bnfsp \bnfts{(} \bnfpn{repr} \bnfsp \bnftd{*}\bnfts{)}}\\
    \bnfmore{\bnfor \bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnfpn{repr}}\\
    \bnfmore{\bnfor \bnftd{return} \bnfsp \bnfpn{repr}}\\
    \bnfmore{\bnfor \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$}}\\
    \bnfmore{\bnfor \bnftd{if} \bnfsp \bnfpn{repr} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mathbf{label}$}}\\
    \bnfprod{move}{\bnfpn{var} \bnfsp \bnftd{$\leftarrow$} \bnfsp \bnfpn{var}}\\
    \bnfprod{$\Phi$}{\bnftd{$\mathbf{label}$} \bnfsp \bnftd{:} \bnfsp \bnfpn{move} \bnfsp \bnftd{*}}\\
    \bnfprod{basicblock}{\bnftd{label} \bnfsp \bnftd{$\mathbf{label}$} \bnfsp \bnftd{:} \bnfsp \bnftd{$\Phi$} \bnfsp \bnftd{[} \bnfsp \bnfpn{$\Phi$} \bnfsp \bnftd{*} \bnfsp \bnftd{]} \bnfsp \bnfpn{instr} \bnfsp \bnftd{+}}\\
    \bnfprod{entryblock}{\bnftd{label} \bnfsp \bnftd{entry} \bnfsp \bnftd{:} \bnfsp \bnftd{$\Phi$} \bnfsp \bnftd{[} \bnfsp \bnfpn{$\Phi$} \bnfsp \bnftd{*} \bnfsp \bnftd{]} \bnfsp \bnfpn{instr} \bnfsp \bnftd{+}}\\
    \bnfprod{basicblocks}{\bnfpn{entryblock} \bnfsp \bnfpn{basicblock} \bnfsp \bnftd{*}}\\
\end{bnf*}


$\mathbf{DYNJIT}^{\mathbf{target}}$  \textbf{Syntax}


\begin{bnf*}
    \bnfprod{absvalue}{\bnfts{(} \bnfpn{repr} \bnfsp \bnftd{,} \bnfsp \bnfpn{type} \bnfts{)}}\\
    \bnfprod{expr}{\bnfpn{absvalue}}\\
    \bnfmore{\bnfor \bnftd{call} \bnfsp \bnfpn{expr} \bnfsp \bnfts{(} \bnfpn{expr} \bnfsp \bnftd{*}\bnfts{)}}\\
    \bnfprod{stmt}{\bnfpn{var} \bnfsp \bnftd{=} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{return} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{if} \bnfsp \bnfpn{expr} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$} \bnfsp \bnftd{goto} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{do} \bnfsp \bnfpn{expr}}\\
    \bnfmore{\bnfor \bnftd{label} \bnfsp \bnftd{$\mbold{label}$}}\\
    \bnfmore{\bnfor \bnftd{\{} \bnfsp \bnfpn{stmts} \bnfsp \bnftd{\}}}\\
    \bnfmore{\bnfor \bnftd{switch} \bnfsp \bnfpn{expr} \bnfsp \bnfpn{case} \bnfsp \bnftd{*}}\\
    \bnfprod{case}{\bnftd{$\mathit{|}$} \bnfsp \bnfpn{type} \bnfsp \bnftd{$\rightarrow$} \bnfsp \bnfpn{stmt}}\\
    \bnfprod{stmts}{\bnfpn{stmt} \bnfsp \bnftd{*}}\\
\end{bnf*}

\newpage

$\mathbf{Types}$

\begin{lstlisting}
type fptr = int
type meth = int
type t =
| $\bot$
| $\top$
| NoneT
| FPtrT  of fptr
| MethT  of meth
| NomT   of string * (string, t) map
| TupleT of t list
| TypeT  of t list
| CellT  of t list
| UnionT of t list
| IntrinT of intrinsic
\end{lstlisting}

A method is a specialised function.

Information of a function, including its definition body
(a \textit{basicblocks} in $\mathbf{DYNJIT}^{\mathbf{source}}$),
variables, arugument information, will be able to lookup with $\mathbf{fptr}$.

Information of a method, including its definition body,
(a \textit{stmts} in $\mathbf{DYNJIT}^{\mathbf{target}}$),
specialised arugument information, will be able to lookup with $\mathbf{meth}$.

Particularly, for the sake of convenience, we use ($t_1 | t_2 | \cdots | t_n$) for
$\mathit{UnionT} \left[ t_1, \cdots, t_n\right]$. In the implementation part,
we always lift up union types to the top level, hence there's no nested union type $\mathit{UnionT} \left[UnionT \cdots \right]$.

Also we use $bool$ for boolean prmitive type $NomT "boolean" \cdots$,
as well as $int$, $float$, etc.

\newpage

$\mathbf{Intrinsics}$ and $\mathbf{Constants}$

\begin{lstlisting}
type intrinsic =
| isinstance
| typeof
| upcast
| downcast

type constant =
| NoneC
| UndefC
| TypeL  of t
| FPtrC  of fptr
| MethC  of meth
| IntC   of int
| FloatC of float
| StrC   of string
| TupleC of const list
| IntrinsicC of intrinsic
\end{lstlisting}

\section*{The Operational Semantics for $source \Rightarrow target$}

We need the following auxiliary symbols for giving the semantics

\begin{itemize}
    \item $r$, $r_1, r_2, \cdots$ are \textit{repr}.
    \item $t$, $t_1, t_2, \cdots$ are \textit{type}.
    \item $a$, $a_1, a_2, \cdots$ are \textit{absvalue}.
    \item $c$, $c_1, c_2, \cdots$ are \textit{const}.
    \item $n$, $n_1, n_2, \cdots$ are variable names, or \textit{var}.
    \item $l$, $l_1, l_2, \cdots$ are \textit{label}.
    \item $L$, $L_1, L_2, \cdots$ are a suite of \textit{stmt} or \textit{instr}, depending on the context.
    \item $\sigma$ : an immutable array $\sigma$ of variables' abstract values. \vbox{}\\
        $\sigma[n := a]$ returns a new array $\sigma^{'}$ having the same length.
        We use $\sigma(n)$ to access a pair of variable $n$'s type representation and data representation.
    \item $F$: Given the index of a function, $i$, $F(i)$ gives the total information of the function.
    \item $M$: Given the index of a method, $i$, $M(i)$ gives the total information of the method.
    \item $ct$: Given the language for a constant, $l$, $ct(l)$ returns the constant value.
    \item $\preceq$: The relationship "more specific than", for instance, $t_1 \preceq t_1 | t_2 $
    \item $\emptyset$ indicates that no residual program is generated.
    \item $\cap_{type}$: type intersection. \vbox{} \\
        $t_1 \cap_{type} t_2$ gives the most general type $t_{12}$ such that
        $t_{12} \preceq t_1 \wedge t_{12} \preceq t_2$.
\end{itemize}


\textbf{Expression}
\begin{equation*}
    \begin{split}
        \dfrac{
        }{
            \sigma \vdash_{expr} S\;c \Rightarrow (S\;a, ct(c))
        }
        \gap
        \dfrac{
        }{
            \sigma \vdash_{expr} D\;n \Rightarrow \sigma(n)
        }
    \end{split}
\end{equation*}


\textbf{Statement}

$$
\dfrac{
    \sigma \vdash_{expr} r \Rightarrow (S \; true, bool)
    \gap
    \sigma \vdash_{block} l_1 \Rightarrow l_1^{'}
}{
    \sigma \vdash_{stmt} \, \mathit{if}\;r\;\mathit{goto}\;l_1\;\mathit{goto}\;l_2\,
    \Rightarrow (\mathit{goto} \; l_1^{'}, \sigma)
} \; (\mathbf{CONST\negsp{-}IF\negsp{-}TRUE})
$$

$$
\dfrac{
    \sigma \vdash_{expr} r \Rightarrow (S \; false, bool)
    \gap
    \sigma \vdash_{block} l_2 \Rightarrow l_2^{'}
}{
    \sigma \vdash_{stmt} \, \mathit{if}\;r\;\mathit{goto}\;l_1\;\mathit{goto}\;l_2\,
    \Rightarrow (\mathit{goto} \; l_2^{'}, \sigma)
} \; (\mathbf{CONST\negsp{-}IF\negsp{-}FALSE})
$$

$$
\dfrac{
    \sigma \vdash_{expr} r \Rightarrow (D \; n_2, t)
    \gap
    a_2 = (D\;n_2, t)
    \gap
    a_1 = (D\;n_1, t)
}{
    \sigma \vdash_{stmt}
    \, n_1 = r \, \Rightarrow (n_1 = a_2, \sigma[n_1 := a_1])
} \; (\mathbf{ASS\negsp{-}VAR})
$$

$$
\dfrac{
    \sigma \vdash_{expr} r \Rightarrow (S\;c, t)
    \gap
    a = (S \; c, t)
}{
    \sigma \vdash_{stmt}
    \, n = r \, \Rightarrow (\emptyset\,, \sigma[n := a])
} \; (\mathbf{ASS\negsp{-}CONST\negsp{-}PROP})
$$

\centerfrac{(\mathbf{STATIC\negsp{-}SPEC\negsp{-}INST})}{
    \sigma \vdash_{expr} r_1 \Rightarrow (r_1^{*}, t_1)
        \gap
    \sigma \vdash_{expr} r_2 \Rightarrow (r_2^{*}, TypeT \; t_2)
}{
    boolean = t_1 \preceq t_2 \ne \textit{No\,Partial\,Order Error}
}{
    \sigma \vdash_{stmt}
     \, n = \mathit{call}\; \mathit{isinstance}(r_1, r_2) \,
    \Rightarrow (\emptyset\,, \sigma[n := (boolean, bool)])
}

\centerfrac{}{
    \sigma \vdash_{expr} r_1 \Rightarrow (D \; n^{'}, \top)
    \gap
    \sigma \vdash_{expr} r_2 \Rightarrow (r_2^{*}, TypeT \; t)
    \gap a_1 = (D \; n^{'}, \top)
    \gap a_2 = (r_2^{*}, TypeT \; t)
}{
    a_n = (D \; n, bool)
    \gap
    \sigma[n := (S\;true, bool)] \vdash_{stmts} L \Rightarrow L^{'}
    \gap
    \sigma[n := (S\;false, bool)] \vdash_{stmts} L \Rightarrow L^{''}
}{
    \sigma \vdash_{stmts}
     \, n = \mathit{call}\; \mathit{isinstance}(r_1, r_2) ; L \,
    \Rightarrow
    n = \mathit{call} \; \mathit{isinstance}(a_1, a_2) ;
    \mathit{if}\; a_n \; \mathit{then} \; L^{'} \; \mathit{else} \; L^{'}
}

\textbf{Statements}

$$
\dfrac{}{
    \sigma \vdash_{stmts} \emptyset \Rightarrow \emptyset
}
$$

$$
\dfrac{
    \sigma \vdash_{stmt} \mathit{instr} \Rightarrow (\mathit{stmt}, \sigma^{'})
    \gap
    \sigma^{'} \vdash_{stmts} L \Rightarrow L^{'}
}{
    \sigma \vdash_{stmts} \mathit{instr}; L \Rightarrow \mathit{stmt}; L^{'}
}
$$

\textbf{Block}

$$
\dfrac{
    l^{'} = \mathbf{Visited}(\sigma, l)
}{
    \sigma \vdash_{block} l \Rightarrow l^{'}
}
$$

\centerfrac{}{
    \emptyset = \mathbf{Visited}(\sigma, l)
    \gap
    L = \mathbf{which\_block}(l)
    \gap
    l^{'} = \mathit{gensym}()
}{
    \mathbf{Visited}(\sigma, l) = l^{'}
    \gap
    \sigma \vdash_{stmt} \Rightarrow L^{'}
    \gap
    \mathbf{Block}(l^{'}) := L^{'}
}{
    \sigma \vdash_{block} l \Rightarrow l^{'}
}

The second rule involves more details. WIP.

\end{document}